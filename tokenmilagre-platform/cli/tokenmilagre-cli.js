#!/usr/bin/env node

/**
 * ü™Ñ TokenMilagre CLI - Centro de Comando para Artigos
 *
 * Features:
 * - Verificar melhores artigos do dia
 * - Criar artigo com Gemini (com an√°lise de sentimento)
 * - Fact-check autom√°tico
 * - Publica√ß√£o com valida√ß√£o
 * - Slugs SEO-friendly autom√°ticos
 */

import prompts from 'prompts';
import fetch from 'node-fetch';
import { readFileSync, writeFileSync, existsSync } from 'fs';
import { resolve, basename } from 'path';
import { homedir } from 'os';
import { exec } from 'child_process';
import { promisify } from 'util';

const execAsync = promisify(exec);

// Configura√ß√£o
const API_BASE = process.env.NEXT_PUBLIC_API_URL || 'http://localhost:3000';
const ARTICLES_DIR = process.env.ARTICLES_DIR || resolve(homedir(), 'Trabalho', 'gemini', 'articles');

// Endpoints
const IMPORT_ENDPOINT = `${API_BASE}/api/articles/import`;
const FACTCHECK_ENDPOINT = `${API_BASE}/api/articles/fact-check`;
const LIST_ENDPOINT = `${API_BASE}/api/articles`;
const ARTICLE_BY_SLUG = (slug) => `${API_BASE}/api/articles/${slug}`;

// Cores ANSI
const colors = {
  reset: '\x1b[0m',
  bright: '\x1b[1m',
  green: '\x1b[32m',
  yellow: '\x1b[33m',
  red: '\x1b[31m',
  cyan: '\x1b[36m',
  blue: '\x1b[34m',
  magenta: '\x1b[35m',
};

function color(text, colorCode) {
  return `${colorCode}${text}${colors.reset}`;
}

// Helper: gerar slug SEO-friendly
function generateSlug(title) {
  return title
    .toLowerCase()
    .normalize('NFD')
    .replace(/[\u0300-\u036f]/g, '') // Remove acentos
    .replace(/[^a-z0-9\s-]/g, '') // Remove caracteres especiais
    .replace(/\s+/g, '-') // Substitui espa√ßos por h√≠fens
    .replace(/-+/g, '-') // Remove h√≠fens duplicados
    .replace(/^-+|-+$/g, ''); // Remove h√≠fens do in√≠cio/fim
}

// Helper: analisar sentimento do artigo com Gemini
async function analyzeSentiment(content, title) {
  try {
    const prompt = `Analise o sentimento desta not√≠cia sobre criptomoedas e responda APENAS com uma palavra: positive, neutral ou negative.

T√çTULO: ${title}

CONTE√öDO:
${content}

Crit√©rios:
- positive: not√≠cia otimista, alta de pre√ßo, ado√ß√£o, regula√ß√£o favor√°vel
- negative: not√≠cia pessimista, queda de pre√ßo, FUD, regula√ß√£o negativa
- neutral: informativa, an√°lise t√©cnica, dados factuais

Responda apenas: positive, neutral ou negative`;

    const { stdout } = await execAsync(`gemini "${prompt.replace(/"/g, '\\"')}"`);
    const sentiment = stdout.trim().toLowerCase();

    // Validar resposta
    if (['positive', 'neutral', 'negative'].includes(sentiment)) {
      return sentiment;
    }

    // Fallback: analisar por palavras-chave
    const contentLower = (title + ' ' + content).toLowerCase();
    const positiveKeywords = ['alta', 'recorde', 'ado√ß√£o', 'bull', 'otimista', 'sucesso', 'crescimento'];
    const negativeKeywords = ['queda', 'crash', 'bear', 'pessimista', 'fraude', 'hack', 'recess√£o'];

    const positiveCount = positiveKeywords.filter(k => contentLower.includes(k)).length;
    const negativeCount = negativeKeywords.filter(k => contentLower.includes(k)).length;

    if (positiveCount > negativeCount) return 'positive';
    if (negativeCount > positiveCount) return 'negative';
    return 'neutral';
  } catch (error) {
    console.warn(color('‚ö†Ô∏è  Erro ao analisar sentimento, usando neutral', colors.yellow));
    return 'neutral';
  }
}

// Helper: detectar categoria do artigo
function detectCategory(title, content) {
  const text = (title + ' ' + content).toLowerCase();

  const categories = {
    bitcoin: ['bitcoin', 'btc'],
    ethereum: ['ethereum', 'eth', 'ether'],
    solana: ['solana', 'sol'],
    defi: ['defi', 'descentralizado', 'yield', 'staking', 'liquidity'],
    nfts: ['nft', 'nfts', 'token n√£o fung√≠vel', 'colecion√°vel'],
    regulacao: ['regula√ß√£o', 'sec', 'cvm', 'lei', 'governo', 'regulat√≥rio'],
  };

  for (const [category, keywords] of Object.entries(categories)) {
    if (keywords.some(k => text.includes(k))) {
      return category;
    }
  }

  return 'bitcoin'; // fallback
}

// Helper: extrair tags relevantes
function extractTags(title, content) {
  const text = (title + ' ' + content).toLowerCase();
  const allTags = [
    'bitcoin', 'btc', 'ethereum', 'eth', 'solana', 'sol',
    'defi', 'nft', 'cripto', 'blockchain', 'mercado',
    'pre√ßo', 'alta', 'queda', 'an√°lise', 'investimento',
    'regula√ß√£o', 'etf', 'halving', 'mining'
  ];

  const foundTags = allTags.filter(tag => text.includes(tag));
  return foundTags.slice(0, 5); // M√°ximo 5 tags
}

// Menu principal
async function main() {
  let exit = false;

  while (!exit) {
    console.clear();
    console.log(color(`
‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïó
‚ïë                                                        ‚ïë
‚ïë  ${color('ü™Ñ TokenMilagre CLI - Centro de Comando', colors.cyan)}          ‚ïë
‚ïë                                                        ‚ïë
‚ï†‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ï£
‚ïë                                                        ‚ïë
‚ïë  ${color('1.', colors.bright)} üìä Verificar artigos do dia                    ‚ïë
‚ïë  ${color('2.', colors.bright)} ‚úçÔ∏è  Criar novo artigo (com Gemini)             ‚ïë
‚ïë  ${color('3.', colors.bright)} üîç Fact-check de artigo                        ‚ïë
‚ïë  ${color('4.', colors.bright)} üöÄ Publicar/Gerenciar artigo                   ‚ïë
‚ïë  ${color('5.', colors.bright)} üìà Estat√≠sticas do sistema                     ‚ïë
‚ïë  ${color('0.', colors.bright)} üëã Sair                                        ‚ïë
‚ïë                                                        ‚ïë
‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù
    `, colors.reset));

    const { option } = await prompts({
      type: 'number',
      name: 'option',
      message: color('Digite sua escolha:', colors.cyan),
      validate: (value) => [0, 1, 2, 3, 4, 5].includes(value) ? true : 'Op√ß√£o inv√°lida',
    });

    switch (option) {
      case 1:
        await showTopArticles();
        break;
      case 2:
        await createArticleInteractive();
        break;
      case 3:
        await factCheckArticle();
        break;
      case 4:
        await manageArticle();
        break;
      case 5:
        await showStatistics();
        break;
      default:
        exit = true;
        break;
    }

    if (!exit) {
      const { continue: cont } = await prompts({
        type: 'toggle',
        name: 'continue',
        message: 'Voltar ao menu?',
        initial: true,
        active: 'Sim',
        inactive: 'N√£o',
      });
      if (!cont) exit = true;
    }
  }

  console.log(color('\nüëã At√© a pr√≥xima! Continue criando artigos incr√≠veis! üöÄ\n', colors.green));
}

// Op√ß√£o 1: Mostrar artigos do dia
async function showTopArticles() {
  console.log(color('\nüìä Consultando artigos do dia...\n', colors.cyan));

  try {
    const res = await fetch(`${LIST_ENDPOINT}?category=all`, { method: 'GET' });
    if (!res.ok) throw new Error(`HTTP ${res.status}`);

    const json = await res.json();
    const articles = json.data || [];

    if (!articles.length) {
      console.log(color('üì≠ Nenhum artigo encontrado. Hora de criar um!\n', colors.yellow));
      return;
    }

    // Ordenar por data (mais recentes primeiro)
    articles.sort((a, b) => new Date(b.publishedAt) - new Date(a.publishedAt));

    console.log(color(`‚úÖ Encontrados ${articles.length} artigo(s):\n`, colors.green));

    articles.slice(0, 15).forEach((article, idx) => {
      const sentimentIcon = {
        positive: 'üü¢',
        neutral: 'üü°',
        negative: 'üî¥'
      }[article.sentiment] || '‚ö™';

      const factCheckInfo = article.factChecked
        ? color(`‚úÖ Verificado (${article.factCheckScore || 'N/A'}%)`, colors.green)
        : color('‚ö†Ô∏è  N√£o verificado', colors.yellow);

      console.log(color(`${idx + 1}. ${article.title}`, colors.bright));
      console.log(`   ${sentimentIcon} Sentiment: ${article.sentiment}`);
      console.log(`   üè∑Ô∏è  Categoria: ${Array.isArray(article.category) ? article.category.join(', ') : article.category}`);
      console.log(`   üîó Slug: ${article.slug}`);
      console.log(`   ${factCheckInfo}`);
      console.log(`   üìÖ Publicado: ${new Date(article.publishedAt).toLocaleString('pt-BR')}`);
      console.log(`   üåê URL: ${API_BASE}/dashboard/noticias/${article.slug}`);
      console.log('');
    });
  } catch (err) {
    console.error(color(`‚ùå Erro ao buscar artigos: ${err.message}`, colors.red));
  }
}

// Op√ß√£o 2: Criar artigo interativo
async function createArticleInteractive() {
  console.log(color('\n‚úçÔ∏è  Vamos criar um novo artigo!\n', colors.cyan));

  const responses = await prompts([
    {
      type: 'select',
      name: 'mode',
      message: 'Escolha o modo de cria√ß√£o:',
      choices: [
        { title: 'ü§ñ Gemini autom√°tico (prompt)', value: 'gemini' },
        { title: 'üìÑ Importar arquivo .md existente', value: 'import' },
        { title: '‚úçÔ∏è  Criar manualmente (editor)', value: 'manual' },
      ],
    },
  ]);

  if (responses.mode === 'gemini') {
    await createWithGemini();
  } else if (responses.mode === 'import') {
    await importExistingMarkdown();
  } else if (responses.mode === 'manual') {
    await createManually();
  }
}

// Criar artigo com Gemini
async function createWithGemini() {
  const { topic, category } = await prompts([
    {
      type: 'text',
      name: 'topic',
      message: 'Sobre o que voc√™ quer escrever?',
      validate: (value) => value.trim() ? true : 'Campo obrigat√≥rio',
    },
    {
      type: 'select',
      name: 'category',
      message: 'Categoria:',
      choices: [
        { title: 'Bitcoin', value: 'bitcoin' },
        { title: 'Ethereum', value: 'ethereum' },
        { title: 'Solana', value: 'solana' },
        { title: 'DeFi', value: 'defi' },
        { title: 'NFTs', value: 'nfts' },
        { title: 'Regula√ß√£o', value: 'regulacao' },
      ],
    },
  ]);

  console.log(color('\nü§ñ Gemini trabalhando...\n', colors.cyan));

  try {
    const prompt = `Crie um artigo completo sobre: ${topic}

Categoria: ${category}

Formato esperado:
- T√≠tulo atraente e informativo
- 3-5 par√°grafos bem estruturados
- Informa√ß√µes atualizadas e precisas
- Tom profissional mas acess√≠vel
- Inclua dados e fatos concretos

Escreva o artigo completo em formato markdown (sem metadados YAML, s√≥ o conte√∫do):`;

    const { stdout } = await execAsync(`gemini "${prompt.replace(/"/g, '\\"')}"`);
    const content = stdout.trim();

    // Extrair t√≠tulo (primeira linha com #)
    const titleMatch = content.match(/^#\s+(.+)$/m);
    const title = titleMatch ? titleMatch[1] : 'Artigo sobre ' + topic;

    // Gerar dados do artigo
    const slug = generateSlug(title);
    const sentiment = await analyzeSentiment(content, title);
    const tags = extractTags(title, content);
    const summary = content.split('\n\n')[1]?.substring(0, 150) || 'Artigo sobre ' + topic;

    console.log(color('\n‚úÖ Artigo gerado!\n', colors.green));
    console.log(color('Preview:', colors.bright));
    console.log(color('‚îÄ'.repeat(60), colors.cyan));
    console.log(content.substring(0, 500) + '...');
    console.log(color('‚îÄ'.repeat(60), colors.cyan));

    const { confirm } = await prompts({
      type: 'toggle',
      name: 'confirm',
      message: 'Salvar este artigo?',
      initial: true,
      active: 'Sim',
      inactive: 'N√£o',
    });

    if (!confirm) {
      console.log(color('‚ùå Artigo descartado.', colors.yellow));
      return;
    }

    // Criar markdown com frontmatter
    const markdown = `---
title: "${title}"
summary: "${summary}"
category: ${category}
tags: [${tags.join(', ')}]
sentiment: ${sentiment}
author: admin@tokenmilagre.xyz
---

${content}

---

**Gerado por:** TokenMilagre CLI + Gemini
**Data:** ${new Date().toLocaleDateString('pt-BR')}
`;

    // Salvar arquivo
    const filename = `${slug}.md`;
    const filepath = resolve(ARTICLES_DIR, filename);
    writeFileSync(filepath, markdown, 'utf-8');

    console.log(color(`\n‚úÖ Artigo salvo: ${filepath}`, colors.green));
    console.log(color('üîÑ O watcher processar√° automaticamente em ~5 segundos...', colors.cyan));

    // Perguntar se quer fazer fact-check
    const { factcheck } = await prompts({
      type: 'toggle',
      name: 'factcheck',
      message: 'Executar fact-check agora?',
      initial: true,
      active: 'Sim',
      inactive: 'N√£o',
    });

    if (factcheck) {
      console.log(color('\nüîç Aguardando processamento...', colors.cyan));
      await new Promise(resolve => setTimeout(resolve, 6000)); // Aguardar watcher
      await runFactCheckBySlug(slug);
    }
  } catch (error) {
    console.error(color(`‚ùå Erro ao criar artigo: ${error.message}`, colors.red));
  }
}

// Importar markdown existente
async function importExistingMarkdown() {
  const { filepath } = await prompts({
    type: 'text',
    name: 'filepath',
    message: 'Caminho do arquivo .md:',
    validate: (value) => {
      const path = resolvePath(value);
      return existsSync(path) ? true : 'Arquivo n√£o encontrado';
    },
  });

  const resolvedPath = resolvePath(filepath);

  try {
    const markdown = readFileSync(resolvedPath, 'utf-8');

    // Verificar se tem frontmatter
    if (!markdown.startsWith('---')) {
      console.log(color('\n‚ö†Ô∏è  Arquivo sem frontmatter. Adicionando metadados...', colors.yellow));

      const { title, category } = await prompts([
        {
          type: 'text',
          name: 'title',
          message: 'T√≠tulo do artigo:',
          validate: (v) => v.trim() ? true : 'Obrigat√≥rio',
        },
        {
          type: 'select',
          name: 'category',
          message: 'Categoria:',
          choices: [
            { title: 'Bitcoin', value: 'bitcoin' },
            { title: 'Ethereum', value: 'ethereum' },
            { title: 'Solana', value: 'solana' },
            { title: 'DeFi', value: 'defi' },
            { title: 'NFTs', value: 'nfts' },
            { title: 'Regula√ß√£o', value: 'regulacao' },
          ],
        },
      ]);

      const sentiment = await analyzeSentiment(markdown, title);
      const tags = extractTags(title, markdown);
      const summary = markdown.split('\n\n')[0]?.substring(0, 150) || title;

      const newMarkdown = `---
title: "${title}"
summary: "${summary}"
category: ${category}
tags: [${tags.join(', ')}]
sentiment: ${sentiment}
author: admin@tokenmilagre.xyz
---

${markdown}`;

      writeFileSync(resolvedPath, newMarkdown, 'utf-8');
      console.log(color('‚úÖ Frontmatter adicionado!', colors.green));
    }

    console.log(color('\nüîÑ Artigo ser√° processado pelo watcher...', colors.cyan));
    console.log(color(`üìÅ Arquivo: ${resolvedPath}`, colors.cyan));
  } catch (error) {
    console.error(color(`‚ùå Erro: ${error.message}`, colors.red));
  }
}

// Criar manualmente
async function createManually() {
  console.log(color('\n‚úçÔ∏è  Modo manual: preencha os dados\n', colors.cyan));

  const responses = await prompts([
    {
      type: 'text',
      name: 'title',
      message: 'T√≠tulo:',
      validate: (v) => v.trim() ? true : 'Obrigat√≥rio',
    },
    {
      type: 'text',
      name: 'summary',
      message: 'Resumo (1-2 linhas):',
      validate: (v) => v.trim() ? true : 'Obrigat√≥rio',
    },
    {
      type: 'select',
      name: 'category',
      message: 'Categoria:',
      choices: [
        { title: 'Bitcoin', value: 'bitcoin' },
        { title: 'Ethereum', value: 'ethereum' },
        { title: 'Solana', value: 'solana' },
        { title: 'DeFi', value: 'defi' },
        { title: 'NFTs', value: 'nfts' },
        { title: 'Regula√ß√£o', value: 'regulacao' },
      ],
    },
    {
      type: 'list',
      name: 'tags',
      message: 'Tags (separadas por v√≠rgula):',
      separator: ',',
    },
    {
      type: 'select',
      name: 'sentiment',
      message: 'Sentimento:',
      choices: [
        { title: 'üü¢ Positive (otimista)', value: 'positive' },
        { title: 'üü° Neutral (neutro)', value: 'neutral' },
        { title: 'üî¥ Negative (pessimista)', value: 'negative' },
      ],
    },
    {
      type: 'text',
      name: 'content',
      message: 'Conte√∫do (markdown):',
      validate: (v) => v.trim() ? true : 'Obrigat√≥rio',
    },
  ]);

  const slug = generateSlug(responses.title);
  const markdown = `---
title: "${responses.title}"
summary: "${responses.summary}"
category: ${responses.category}
tags: [${responses.tags.join(', ')}]
sentiment: ${responses.sentiment}
author: admin@tokenmilagre.xyz
---

${responses.content}`;

  const filename = `${slug}.md`;
  const filepath = resolve(ARTICLES_DIR, filename);
  writeFileSync(filepath, markdown, 'utf-8');

  console.log(color(`\n‚úÖ Artigo criado: ${filepath}`, colors.green));
  console.log(color('üîÑ Ser√° processado automaticamente pelo watcher', colors.cyan));
}

// Op√ß√£o 3: Fact-check de artigo
async function factCheckArticle() {
  console.log(color('\nüîç Fact-check de artigo\n', colors.cyan));

  const { method } = await prompts({
    type: 'select',
    name: 'method',
    message: 'Escolha o m√©todo:',
    choices: [
      { title: 'üîó Por slug (artigo j√° publicado)', value: 'slug' },
      { title: 'üìÑ Por arquivo .md', value: 'file' },
    ],
  });

  if (method === 'slug') {
    const { slug } = await prompts({
      type: 'text',
      name: 'slug',
      message: 'Slug do artigo:',
      validate: (v) => v.trim() ? true : 'Obrigat√≥rio',
    });

    await runFactCheckBySlug(slug);
  } else {
    const { filepath } = await prompts({
      type: 'text',
      name: 'filepath',
      message: 'Caminho do arquivo .md:',
      validate: (value) => {
        const path = resolvePath(value);
        return existsSync(path) ? true : 'Arquivo n√£o encontrado';
      },
    });

    const resolvedPath = resolvePath(filepath);
    const markdown = readFileSync(resolvedPath, 'utf-8');
    await runFactCheck(markdown);
  }
}

async function runFactCheckBySlug(slug) {
  try {
    // Buscar artigo
    const res = await fetch(ARTICLE_BY_SLUG(slug));
    if (!res.ok) throw new Error('Artigo n√£o encontrado');

    const json = await res.json();
    if (!json.success) throw new Error('Erro ao buscar artigo');

    const article = json.data;

    if (article.factChecked) {
      console.log(color('\n‚úÖ Este artigo j√° foi verificado:', colors.green));
      console.log(`   Score: ${article.factCheckScore || 'N/A'}%`);
      console.log(`   Status: ${article.factChecked ? 'Verificado' : 'N√£o verificado'}`);
      console.log('');
    }

    // Montar markdown para fact-check
    const markdown = `---
title: "${article.title}"
summary: "${article.summary}"
category: ${Array.isArray(article.category) ? article.category[0].toLowerCase() : article.category}
tags: ${JSON.stringify(article.keywords || [])}
sentiment: ${article.sentiment}
---

${article.content}`;

    await runFactCheck(markdown);
  } catch (error) {
    console.error(color(`‚ùå Erro: ${error.message}`, colors.red));
  }
}

async function runFactCheck(markdown) {
  console.log(color('\nüîç Executando fact-check...\n', colors.cyan));

  try {
    const res = await fetch(FACTCHECK_ENDPOINT, {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({ markdown, threshold: 70, maxClaims: 10 }),
    });

    if (!res.ok) throw new Error(`HTTP ${res.status}`);
    const json = await res.json();

    if (!json.success) throw new Error('Fact-check falhou');

    const data = json.data;

    console.log(color('üìä Resultado do Fact-Check:', colors.bright));
    console.log(color('‚ïê'.repeat(60), colors.cyan));
    console.log('');

    const statusColor = data.passed ? colors.green : colors.red;
    const statusIcon = data.passed ? '‚úÖ' : '‚ùå';

    console.log(`${color(`${statusIcon} Status:`, statusColor)} ${data.status.toUpperCase()}`);
    console.log(`üìà Score: ${color(`${data.score}/${data.threshold}`, statusColor)}`);
    console.log(`üìÑ Claims analisados: ${data.totalClaims}`);
    console.log(`‚úÖ Verificados: ${color(data.verifiedClaims, colors.green)}`);
    console.log(`‚ùå N√£o verificados: ${color(data.failedClaims, colors.red)}`);
    console.log(`üîó Fontes consultadas: ${data.sources.length}`);
    console.log(`üîç APIs usadas: ${data.searchAPIsUsed.join(', ') || 'Nenhuma'}`);
    console.log('');

    if (data.verifications && data.verifications.length > 0) {
      console.log(color('üìã Detalhes das Verifica√ß√µes:', colors.bright));
      console.log(color('‚îÄ'.repeat(60), colors.cyan));

      data.verifications.forEach((v, idx) => {
        const icon = v.verified ? '‚úÖ' : '‚ùå';
        console.log(`\n${idx + 1}. ${v.claim}`);
        console.log(`   ${icon} Confian√ßa: ${v.confidence}%`);
        console.log(`   üìö Fontes: ${v.sourcesCount}`);
        console.log(`   üí° ${v.reasoning}`);
      });
    }

    console.log('\n' + color('‚ïê'.repeat(60), colors.cyan));
  } catch (error) {
    console.error(color(`‚ùå Erro ao executar fact-check: ${error.message}`, colors.red));
  }
}

// Op√ß√£o 4: Gerenciar artigo
async function manageArticle() {
  console.log(color('\nüöÄ Gerenciamento de Artigos\n', colors.cyan));

  const { slug } = await prompts({
    type: 'text',
    name: 'slug',
    message: 'Slug do artigo:',
    validate: (v) => v.trim() ? true : 'Obrigat√≥rio',
  });

  try {
    const res = await fetch(ARTICLE_BY_SLUG(slug));
    if (!res.ok) throw new Error('Artigo n√£o encontrado');

    const json = await res.json();
    if (!json.success) throw new Error('Erro ao buscar artigo');

    const article = json.data;

    console.log(color('\nüìÑ Artigo:', colors.bright));
    console.log(color('‚îÄ'.repeat(60), colors.cyan));
    console.log(`T√≠tulo: ${article.title}`);
    console.log(`Slug: ${article.slug}`);
    console.log(`Categoria: ${Array.isArray(article.category) ? article.category.join(', ') : article.category}`);
    console.log(`Sentiment: ${article.sentiment}`);
    console.log(`Fact-check: ${article.factChecked ? `‚úÖ ${article.factCheckScore}%` : '‚ùå N√£o verificado'}`);
    console.log(`URL: ${API_BASE}/dashboard/noticias/${article.slug}`);
    console.log(color('‚îÄ'.repeat(60), colors.cyan));

    console.log(color('\n‚úÖ Artigo j√° est√° publicado!', colors.green));
    console.log(color(`üåê Acesse: ${API_BASE}/dashboard/noticias/${article.slug}`, colors.cyan));
  } catch (error) {
    console.error(color(`‚ùå Erro: ${error.message}`, colors.red));
  }
}

// Op√ß√£o 5: Estat√≠sticas
async function showStatistics() {
  console.log(color('\nüìà Estat√≠sticas do Sistema\n', colors.cyan));

  try {
    const res = await fetch(`${LIST_ENDPOINT}?category=all`);
    if (!res.ok) throw new Error(`HTTP ${res.status}`);

    const json = await res.json();
    const articles = json.data || [];

    const total = articles.length;
    const verified = articles.filter(a => a.factChecked).length;
    const positive = articles.filter(a => a.sentiment === 'positive').length;
    const neutral = articles.filter(a => a.sentiment === 'neutral').length;
    const negative = articles.filter(a => a.sentiment === 'negative').length;

    const avgScore = verified > 0
      ? (articles.filter(a => a.factCheckScore).reduce((sum, a) => sum + a.factCheckScore, 0) / verified).toFixed(1)
      : 0;

    console.log(color('üìä Estat√≠sticas Gerais:', colors.bright));
    console.log(color('‚ïê'.repeat(60), colors.cyan));
    console.log(`\nüìÑ Total de artigos: ${color(total, colors.bright)}`);
    console.log(`‚úÖ Verificados: ${color(verified, colors.green)} (${((verified / total) * 100).toFixed(1)}%)`);
    console.log(`‚ö†Ô∏è  N√£o verificados: ${color(total - verified, colors.yellow)}`);
    console.log(`üìà Score m√©dio: ${color(avgScore + '%', colors.cyan)}`);

    console.log(`\n${color('Sentimentos:', colors.bright)}`);
    console.log(`üü¢ Positive: ${color(positive, colors.green)} (${((positive / total) * 100).toFixed(1)}%)`);
    console.log(`üü° Neutral: ${color(neutral, colors.yellow)} (${((neutral / total) * 100).toFixed(1)}%)`);
    console.log(`üî¥ Negative: ${color(negative, colors.red)} (${((negative / total) * 100).toFixed(1)}%)`);

    console.log('\n' + color('‚ïê'.repeat(60), colors.cyan));
  } catch (error) {
    console.error(color(`‚ùå Erro: ${error.message}`, colors.red));
  }
}

// Helper: resolver path com ~
function resolvePath(inputPath) {
  if (!inputPath) return inputPath;
  if (inputPath.startsWith('~')) {
    return resolve(homedir(), inputPath.slice(2));
  }
  return resolve(inputPath);
}

// Executar
main().catch((err) => {
  console.error(color(`\nüí• Erro inesperado: ${err.message}`, colors.red));
  process.exit(1);
});
